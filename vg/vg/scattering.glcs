#version 430

layout(local_size_x = 32) in;


// per particle position

layout(std430, binding = 0) readonly buffer particleStorage
{
	vec4 particle[];
};


// per voxel density value

layout(std430, binding = 1) coherent buffer densityStorage
{
	uint density[];
};
       

uniform float cell_size;

uniform uint cell_count;

uniform float particle_size;

uniform uint particle_count;


const vec3 samples[27] =
{
	vec3( 1, 1, 1 ) / 6.0 * cell_size,
	vec3( 3, 1, 1 ) / 6.0 * cell_size,
	vec3( 5, 1, 1 ) / 6.0 * cell_size,
	vec3( 1, 3, 1 ) / 6.0 * cell_size,
	vec3( 3, 3, 1 ) / 6.0 * cell_size,
	vec3( 5, 3, 1 ) / 6.0 * cell_size,
	vec3( 1, 5, 1 ) / 6.0 * cell_size,
	vec3( 3, 5, 1 ) / 6.0 * cell_size,
	vec3( 5, 5, 1 ) / 6.0 * cell_size,
	vec3( 1, 1, 3 ) / 6.0 * cell_size,
	vec3( 3, 1, 3 ) / 6.0 * cell_size,
	vec3( 5, 1, 3 ) / 6.0 * cell_size,
	vec3( 1, 3, 3 ) / 6.0 * cell_size,
	vec3( 3, 3, 3 ) / 6.0 * cell_size,
	vec3( 5, 3, 3 ) / 6.0 * cell_size,
	vec3( 1, 5, 3 ) / 6.0 * cell_size,
	vec3( 3, 5, 3 ) / 6.0 * cell_size,
	vec3( 5, 5, 3 ) / 6.0 * cell_size,
	vec3( 1, 1, 5 ) / 6.0 * cell_size,
	vec3( 3, 1, 5 ) / 6.0 * cell_size,
	vec3( 5, 1, 5 ) / 6.0 * cell_size,
	vec3( 1, 3, 5 ) / 6.0 * cell_size,
	vec3( 3, 3, 5 ) / 6.0 * cell_size,
	vec3( 5, 3, 5 ) / 6.0 * cell_size,
	vec3( 1, 5, 5 ) / 6.0 * cell_size,
	vec3( 3, 5, 5 ) / 6.0 * cell_size,
	vec3( 5, 5, 5 ) / 6.0 * cell_size
};

void contribute(uvec3 cell_coordinates, vec3 particle_position)
{
	// get cell position

		vec3 cell_position = vec3(cell_coordinates) * cell_size;

	// get cell index

		uint cell_index = cell_count * cell_count * cell_coordinates.z + cell_count * cell_coordinates.y + cell_coordinates.x;

	// check if voxel is inside
		
		/*
		float bounding_sphere = length(vec3(cell_size / 2));

		float distance = length(particle_position - cell_position - samples[13]);
		
		if(particle_size >= distance + bounding_sphere)
		{
			atomicAdd(density[cell_index], 27);

			return;
		}
		*/

	// count sampling points inside particle

		uint count = 0;

		float a = pow(particle_size, 2);

		for(uint s = 0; s < 27; s++)
		{
			vec3 sample_position = cell_position + samples[s];
			
			vec3 distance_vector = particle_position - sample_position;
			if(dot(distance_vector, distance_vector) <= a) count++;
		}

	// add count as contribution to cell

		atomicAdd(density[cell_index], count);
} 

void main()
{
	// get particle

		uint particle_index = gl_GlobalInvocationID.x;

		if(particle_index >= particle_count) return;

		vec3 particle_position = particle[particle_index].xyz;
		
	// get intersected cells

		vec3 offset = vec3(particle_size);

		uvec3 min = clamp(uvec3((particle_position - offset) * cell_count), uvec3(0), uvec3(cell_count - 1));

		uvec3 max = clamp(uvec3((particle_position + offset) * cell_count), uvec3(0), uvec3(cell_count - 1));

	// for each cell contribute density
		
		for(uint z = min.z; z <= max.z; z++)
		{
			for(uint y = min.y; y <= max.y; y++)
			{
				for(uint x = min.x; x <= max.x; x++)
				{
					contribute(uvec3(x, y, z), particle_position);
				}
			}
		}
}