#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;


// per cell particle count

layout(std430, binding = 3) readonly buffer counterSSBO
{
	uint count[];
};


// per cell start address

layout(std430, binding = 4) readonly buffer prefixsumSSBO
{
	uint prefixsum[];
};


// per cell sorted particles

layout(std430, binding = 6) readonly buffer sortedSSBO
{
	float sorted[];
};


// per voxel density value

layout(std430, binding = 7) writeonly buffer densitySSBO
{
	uint density[];
};


uniform float voxel_size;

uniform uint voxel_count;

// uniform float cell_size;

uniform uint cell_count;

uniform float particle_size;

uniform float voxel_radius;

const vec3 samples[27] =
{
	vec3( 1, 1, 1 ) / 6.0 * voxel_size,
	vec3( 3, 1, 1 ) / 6.0 * voxel_size,
	vec3( 5, 1, 1 ) / 6.0 * voxel_size,
	vec3( 1, 3, 1 ) / 6.0 * voxel_size,
	vec3( 3, 3, 1 ) / 6.0 * voxel_size,
	vec3( 5, 3, 1 ) / 6.0 * voxel_size,
	vec3( 1, 5, 1 ) / 6.0 * voxel_size,
	vec3( 3, 5, 1 ) / 6.0 * voxel_size,
	vec3( 5, 5, 1 ) / 6.0 * voxel_size,
	vec3( 1, 1, 3 ) / 6.0 * voxel_size,
	vec3( 3, 1, 3 ) / 6.0 * voxel_size,
	vec3( 5, 1, 3 ) / 6.0 * voxel_size,
	vec3( 1, 3, 3 ) / 6.0 * voxel_size,
	vec3( 3, 3, 3 ) / 6.0 * voxel_size,
	vec3( 5, 3, 3 ) / 6.0 * voxel_size,
	vec3( 1, 5, 3 ) / 6.0 * voxel_size,
	vec3( 3, 5, 3 ) / 6.0 * voxel_size,
	vec3( 5, 5, 3 ) / 6.0 * voxel_size,
	vec3( 1, 1, 5 ) / 6.0 * voxel_size,
	vec3( 3, 1, 5 ) / 6.0 * voxel_size,
	vec3( 5, 1, 5 ) / 6.0 * voxel_size,
	vec3( 1, 3, 5 ) / 6.0 * voxel_size,
	vec3( 3, 3, 5 ) / 6.0 * voxel_size,
	vec3( 5, 3, 5 ) / 6.0 * voxel_size,
	vec3( 1, 5, 5 ) / 6.0 * voxel_size,
	vec3( 3, 5, 5 ) / 6.0 * voxel_size,
	vec3( 5, 5, 5 ) / 6.0 * voxel_size
};

uint gather(uint cell_index, vec3 voxel_position)
{
	uint particle_count = count[cell_index];

	if(particle_count == 0) return 0;

	uint local_density = 0;

	uint cell_start = prefixsum[cell_index];

	float a = pow(particle_size + voxel_radius, 2);
	float b = pow(particle_size - voxel_radius, 2);
	float c = pow(particle_size, 2);

	for(uint p = 0; p < particle_count; p++)
	{
		uint particle_start = (cell_start + p) * 3;

		vec3 particle_position = vec3(sorted[particle_start], sorted[particle_start + 1], sorted[particle_start + 2]);
		
		vec3 early_vector = particle_position - voxel_position;
		float squared_distance = dot(early_vector, early_vector);
		if(squared_distance >= a) continue;
		
		if(squared_distance <= b)
		{
			local_density += 27;
			continue;
		}
		
		for(uint s = 0; s < 27; s++)
		{
			vec3 sample_position = voxel_position + samples[s];
			vec3 distance_vector = particle_position - sample_position;
			if(dot(distance_vector, distance_vector) <= c) local_density++;
		}
	}

	local_density = particle_count;

	return local_density;
}


void main()
{
	// get voxel
	
		if(gl_GlobalInvocationID.x >= voxel_count || gl_GlobalInvocationID.y >= voxel_count || gl_GlobalInvocationID.z >= voxel_count) return;

		vec3 voxel_position = gl_GlobalInvocationID * voxel_size + vec3(voxel_size / 2);

	// get search cells

		vec3 offset = vec3(voxel_size / 2 + particle_size);

		uvec3 min = clamp(uvec3((voxel_position - offset) * cell_count), uvec3(0), uvec3(cell_count - 1));

		uvec3 max = clamp(uvec3((voxel_position + offset) * cell_count), uvec3(0), uvec3(cell_count - 1));

	// for each cell gather density

		uint voxel_density = 0;

		for(uint z = min.z; z <= max.z; z++)
		{
			for(uint y = min.y; y <= max.y; y++)
			{
				for(uint x = min.x; x <= max.x; x++)
				{
					voxel_density += gather(z * cell_count * cell_count + y * cell_count + x, voxel_position);
				}
			}
		}

	// store density to voxel

		uint voxel_index = gl_GlobalInvocationID.z * voxel_count * voxel_count + gl_GlobalInvocationID.y * voxel_count + gl_GlobalInvocationID.x;
				
		density[voxel_index] = voxel_density;
}

