#version 430

out vec4 fragment_color;

layout(binding = 0) uniform sampler2D position_texture;
layout(binding = 1) uniform sampler2D normal_texture;

struct ray
{
	vec3 origin;
	vec3 direction;
};

struct sphere
{
	vec3 center;
	float radius;
};

float intersect(ray r, sphere s)
{
	vec3 oc = r.origin - s.center;
	float b = dot(r.direction, oc);
	float c = dot(oc, oc) - s.radius * s.radius;
	float t = b * b - c;
	if( t > 0.0) t = -b - sqrt(t);
	return t;
}

void main()
{
	vec3 fragment_position = texture(position_texture, gl_FragCoord.xy / vec2(1280, 720)).xyz;
    vec3 fragment_normal = texture(normal_texture, gl_FragCoord.xy / vec2(1280, 720)).xyz;

	if(fragment_position == vec3(0)) discard;

	ray r = ray(fragment_position, fragment_normal);

	float intersection = 0;
	uint step = 0;

	/*
	while(intersection == 0 && step < 10)
	{
		// get next hash cell



		// intersect all spheres



		step++;
	}
	*/

	float diffuse = clamp(dot(normalize(fragment_normal), normalize(vec3(-10, 10, 10))), 0.0, 1.0);
	fragment_color = diffuse * vec4(0.1, 0.1, 0.6, 0) + vec4(0.1, 0.1, 0.4, 1);
}