#version 430

layout(binding = 0) uniform sampler2D position_texture;
layout(binding = 1) uniform sampler2D normal_texture;

layout(r32f) uniform image2D occlusion_texture;

layout(std430, binding = 7) buffer densitySSBO
{
	uint density[];
};

uniform float opening_angle;
uniform uint voxel_count;
uniform float voxel_size;
uniform uint voxel_levels;
uniform uint level_offsets[9];

struct cone
{
	vec3 origin;
	vec3 direction;
	float alpha;
	float beta;
};

void main()
{
	vec3 fragment_position = texture(position_texture, gl_FragCoord.xy / vec2(1280, 720)).xyz;
    vec3 fragment_normal = texture(normal_texture, gl_FragCoord.xy / vec2(1280, 720)).xyz;

	if(fragment_position == vec3(0) || fragment_normal == vec3(0)) discard;

	cone c;
	c.origin = fragment_position + fragment_normal * voxel_size;
	c.direction = fragment_normal;
	c.alpha = opening_angle / 2.0;
	c.beta = 1.5708 - c.alpha;

	vec3 sample_position = c.origin;
	float sample_distance = voxel_size;
	uint sample_level = 0;
	uint level_size = voxel_count; 

	float occlusion = 0.0;
	float occlusion_distance = 0.0;

	float lambda = 0.1;
	float cone_radius = (sample_distance / sin(c.beta)) * sin(c.alpha);

	uint iteration = 0;

	while(sample_distance < sqrt(3.0))
	{
		// get current density value 

			uvec3 voxel_position = uvec3(sample_position * float(level_size));
			uint voxel_index = voxel_position.x + level_size * (voxel_position.y + level_size * voxel_position.z);
			uint level_offset = level_offsets[sample_level];
			float density_value = min(float(density[level_offset + voxel_index]) / 270.0, 1.0);
		
		// update occlusion
			
			float weight = 1.0 / (1.0 + lambda * cone_radius);
			occlusion = occlusion + (1.0 - occlusion) * density_value * weight;
			occlusion_distance = sample_distance;

		// update sampling position

			sample_distance += voxel_size * pow(2, sample_level);
 			sample_position = c.origin + c.direction * sample_distance;

			if(sample_position.x < 0.0 || sample_position.x > 1.0 || sample_position.y < 0.0 || sample_position.y > 1.0 || sample_position.z < 0.0 || sample_position.z > 1.0)
			{
				break;
			}

		// update sampling level

			cone_radius = (sample_distance / sin(c.beta)) * sin(c.alpha);
			sample_level = min(uint(ceil(log((cone_radius * 2.0) / voxel_size) / log(2.0))), voxel_levels);

		// update level resolution

			level_size = voxel_count / uint(pow(2, sample_level));

			iteration++;
	}

	imageStore(occlusion_texture, ivec2(gl_FragCoord.xy), vec4(pow(1 - occlusion, 3.0)));

	discard;
}